// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./base/ProxyAIRouter.sol";

/**
 * @title CustomRouter
 * @dev This contract extends the ProxyAIRouter to allow custom logic execution after receipt processing.
 * Users can implement their custom logic in the _onReceipt function.
 */
contract CustomRouter is ProxyAIRouter {
  // Event to log custom actions
  event RequestProcessed(bytes32 indexed messageId, PayFeesIn payFeesIn);
  event ReceiptProcessed(
    bytes32 indexed receiptMessageId,
    bytes32 indexed idempotencyKey,
    uint256 usedTokens
  );

  constructor(
    address _router,
    address _link,
    address _controller,
    address _controllerVault,
    address _token,
    uint64 _controllerChainSelector
  )
    ProxyAIRouter(_router, _link, _controller, _controllerVault, _token, _controllerChainSelector)
  {}

  /**
   * @dev This function is called after a key is generated.
   * Implement custom logic here to define what happens when a key is generated.
   * @param messageId The ID of the ccip message sent to the controller.
   * @param payFeesIn The method used to pay for fees (Native or LINK).
   */
  function _onRequest(bytes32 messageId, PayFeesIn payFeesIn) internal override {
    // Example of custom logic:
    // 1. Emit an event for external tracking
    emit RequestProcessed(messageId, payFeesIn);

    // 2. Perform additional checks or actions
    // For example, you could update a mapping to track pending requests
    // pendingRequests[messageId] = true;

    // 3. Trigger off-chain tracking or automation
    // Note: This would typically involve emitting an event that an off-chain service listens for
    // The off-chain service could then track the messageId for success
  }

  /**
   * @dev This function is called after a receipt is processed.
   * Implement custom logic here to define what happens when a key is utilized.
   * @param receiptMessageId The  message Id associated with  the original request sent to the controller.
   * @param idempotencyKey The unique session key generated by the controller from the request.
   * @param usedTokens The amount of tokens used offchain.
   */
  function _onReceipt(
    bytes32 receiptMessageId,
    bytes32 idempotencyKey,
    uint256 usedTokens
  ) internal override {
    // Example of custom logic:
    // 1. Emit an event for external tracking
    emit ReceiptProcessed(receiptMessageId, idempotencyKey, usedTokens);

    // 2. Perform additional checks or actions based on usedTokens
    if (usedTokens > 100 * 1e18) {
      // If more than 100 tokens were used
      // Implement some special logic for high-value transactions
      // For example, you could call an external contract or update internal state
    }

    // 3. Update internal state or perform other custom actions
    // Note: Be mindful of gas costs when implementing complex logic
  }
}
